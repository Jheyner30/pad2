<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Durazno1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Durazno1_files/libs/clipboard/clipboard.min.js"></script>
<script src="Durazno1_files/libs/quarto-html/quarto.js"></script>
<script src="Durazno1_files/libs/quarto-html/popper.min.js"></script>
<script src="Durazno1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Durazno1_files/libs/quarto-html/anchor.min.js"></script>
<link href="Durazno1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Durazno1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Durazno1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Durazno1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Durazno1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Durazno1</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>```</p>
<section id="i.-introducción" class="level2">
<h2 class="anchored" data-anchor-id="i.-introducción">I. Introducción</h2>
<p>El etiquetado de imágenes es una tarea fundamental en proyectos de análisis de datos y aprendizaje automático, ya que permite clasificar y anotar datos visuales para entrenar modelos de inteligencia artificial. En este proyecto, se realizó el etiquetado de 50 imágenes que incluyen hojas y monedas utilizando Label Studio, una herramienta de código abierto diseñada para la anotación de datos.</p>
<p>El objetivo principal fue preparar un dataset de imágenes etiquetadas que pueda ser utilizado en futuras investigaciones o aplicaciones prácticas, como la identificación automática de especies de plantas o el reconocimiento de objetos. Para llevar a cabo este proceso, se configuró un entorno de trabajo basado en Anaconda y se utilizaron las funcionalidades de Label Studio para crear anotaciones precisas.</p>
<p>En esta página se describe paso a paso el proceso seguido, desde la instalación de los programas necesarios hasta la finalización del etiquetado. Además, se presentan algunos ejemplos de las imágenes etiquetadas, destacando la utilidad de este procedimiento en contextos académicos y tecnológicos.</p>
</section>
<section id="ii.-instalación-de-anaconda" class="level2">
<h2 class="anchored" data-anchor-id="ii.-instalación-de-anaconda">II. Instalación de Anaconda</h2>
<p><strong>¿Que es Anaconda?</strong></p>
<p>Anaconda es una distribución gratuita y de código abierto de Python y R que incluye una colección de paquetes, bibliotecas y herramientas diseñadas específicamente para el análisis de datos, aprendizaje automático y computación científica. Una de las principales ventajas de Anaconda es su facilidad para crear y gestionar entornos virtuales, lo que permite trabajar en proyectos con diferentes configuraciones sin generar conflictos entre dependencias.</p>
<p>En este proyecto, se utilizó Anaconda para instalar y ejecutar Label Studio, una herramienta clave para el etiquetado de imágenes. Anaconda proporcionó un entorno controlado donde fue posible instalar todas las dependencias necesarias sin interferir con otras configuraciones del sistema.</p>
<ul>
<li>Como se instala:</li>
</ul>
<p>Nos dirigimos a la pagina oficial de Anaconda:<a href="https://www.anaconda.com/download/success" class="uri">https://www.anaconda.com/download/success</a></p>
<p>En esta parte tendremos 2 opciones las cuales son Anaconda que vendria a ser una version mas completa para ser utilizada y la version Miniconda es la mas accesible para su manejo por si no presentas con mucho espacio en tu dispositivo. En nuestro caso grupal escogimos la version Miniconda.</p>
<p><img src="images/clipboard-1531883907.png" class="img-fluid"></p>
<p>Una vez instalado presionamos windows y buscamos anaconda.</p>
<p><img src="images/clipboard-1226016778.png" class="img-fluid"></p>
<p>Entramos al sistema y se abrira la interfaz gráfica de Anaconda.</p>
<p><img src="images/clipboard-4092527107.png" class="img-fluid"></p>
<p>En este punto se necesita 2 comandos para ejecutar, por lo cual iremos al siguiente link: <a href="https://labelstud.io/" class="uri">https://labelstud.io/</a></p>
<p><img src="images/clipboard-1846766318.png" class="img-fluid"></p>
<p><strong>Inicio rapido:</strong> En esta parte nos aparecen 2 comandos.</p>
<ul>
<li><p>pip install -U label-studio: este comando se ejecuta en Anaconda para que este realize la instalacion de paquetes necesarios para utilizar. Este proceso puede demorar.</p></li>
<li><p>label-studio: este comado sirve para iniciar sesion ya en la pagina de Label Studio, al comienzo se abrira la pagina en tu navegador y tendras que crear una cuenta, una vez realizado este proceso ya tendras tu cuenta disponible para utilizar.</p></li>
</ul>
<p><strong><em>Nota:</em></strong> La interfaz grafica de anaconda debe estar siempre abierta o ejecutada si quieres utilizar tu cuenta de Label Studio ya qeu funcionan al simultaneo. Y para iniciar una vez cerrado todo, solo abres la interfaz de anaconda y ejecutas el segundo codigo.</p>
<p><img src="images/clipboard-232235857.png" class="img-fluid"></p>
</section>
<section id="iii.-label-studio" class="level2">
<h2 class="anchored" data-anchor-id="iii.-label-studio">III. Label Studio</h2>
<p><strong>¿Que es?</strong></p>
<p>Label Studio es una&nbsp;herramienta open-source de etiquetado de datos. Permite etiquetar tipos de datos como audio, texto, imágenes, vídeos y series temporales con una interfaz de usuario sencilla y luego exportar a varios formatos de modelos.</p>
<p><strong>Proceso de etiquetado:</strong></p>
<ul>
<li><strong>Paso 1:</strong></li>
</ul>
<p>Se debe tener las imagenes descargadas en tu dispositivo en formato JPG.</p>
<p><img src="images/clipboard-189318481.png" class="img-fluid"></p>
<ul>
<li><strong>Paso 2:</strong></li>
</ul>
<p>Se crea un proyecto nuevo en la pagina de Label Studio, se presentara lo siguiente.</p>
<p><img src="images/clipboard-2724306985.png" class="img-fluid"></p>
<p>Llenas el nombre de tu proyecto, si deseas se agrega una descripción.</p>
<p><img src="images/clipboard-3652832439.png" class="img-fluid"></p>
<p>En importacion de datos subes las imagenes que quieres etiquetar.</p>
<p>Se debe de ver de esta manera:</p>
<p><img src="images/clipboard-645823921.png" class="img-fluid"></p>
<p>En la parte de configuración de etiquetado, aparecerán diferentes tipos de equitado, el que se uso para este trabajo fue la primera opción que se llama: segmentación semántica con poligonos.</p>
<p><img src="images/Captura%20de%20pantalla%202024-12-12%20160458.png" class="img-fluid"></p>
<p>Seleccionamos la opción y nos mostrará lo siguiente.</p>
<p><img src="images/clipboard-2347700261.png" class="img-fluid"></p>
<p>En esta parte solo agregamos los nombres de la etiqueta: Hoja y Moneda y das add; se selecciona el color que mas deseemos al presionar en la etiqueta, obviamente se borra las etiquetas que nos muestran como ejemplo. Luego de eso seleccionamos los cuadrados sin marcar en configurar ajustes y damos ahorrar o save si esta en ingles su pagina.</p>
</section>
<section id="iv.-ejecución-para-el-etiquetado" class="level2">
<h2 class="anchored" data-anchor-id="iv.-ejecución-para-el-etiquetado">IV. Ejecución para el etiquetado</h2>
<p>Continuando con lo ya mencionado, las imagenes que cargaste te aparecerán de la siguiente manera en tu proyecto.</p>
<p><img src="images/clipboard-1103238774.png" class="img-fluid"></p>
<p>Lo que se tiene que hacer aqui y lo que se hizo con el resto de integrados del grupo de trabajo fue selecionar imagen por imagen y hacer el etiquetado de cada uno.</p>
<ul>
<li><p>Al selecionar una de las imagenes te aparecerán la etiqueta de Hoja y Moneda al pie de la imagen.</p></li>
<li><p>En la parte derecha se veran comandos para usar al momento de etiquetar la imagen.</p></li>
</ul>
<p><img src="images/clipboard-637353424.png" class="img-fluid"></p>
<p><strong>COMANDOS:</strong></p>
<ol type="1">
<li><p>Flecha: sirve para mover.</p></li>
<li><p>Manito: Sirve para agarrar la imagen para tener una vista panorámica.</p></li>
<li><p>Lupa con un +: Sirve para ahacer zoom.</p></li>
<li><p>Cuadrado con flechitas en su interior: sirve para apliar y ajustar el tamaño real de la imagen.</p></li>
<li><p>Lupa con -: sirve para quitar el zoom.</p></li>
<li><p>Dos ultimos comandos: sirve para girar la imagen ya sea derecha o izquierda.</p></li>
</ol>
<ul>
<li>Al selecionar el etiquetado en este caso de Hoja y presionar en la imagen correspondiente se presentara un punto del color seleccionado y solo se debe delinear el contor de la hoja hasta cerrar con el primer punto, como se muestra a continuación:</li>
</ul>
<p><img src="images/clipboard-1154799073.png" class="img-fluid"></p>
<p><img src="images/clipboard-3740183665.png" class="img-fluid"></p>
<ul>
<li>Luego de esto se selecciona la etiqueta moneda y se realiza lo mismo.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3498498930.png" class="img-fluid figure-img"></p>
<figcaption><img src="images/clipboard-1899935822.png" class="img-fluid figure-img"></figcaption>
</figure>
</div>
<p><img src="images/clipboard-2882767075.png" class="img-fluid"></p>
<ul>
<li>Al utilizar los comandos mencionados se puede hacer un etiquetado mas preciso y preciso.</li>
</ul>
<p>Damos en entragar y ya estaria, este proceso se realiza en todas las imagenes que se subieron al momento de crear el proyecto.</p>
<ul>
<li><p>Teniendo ya todos las imagenes etiquetadas se exporta los datos obtenidos en el formato Coco o Palma deCoco.</p>
<p><img src="images/clipboard-2265180611.png" class="img-fluid"></p></li>
</ul>
<p>Los datos exportados suelen servir para entrenar algoritmos de aprendizaje, entre otras cosas.</p>
</section>
<section id="v.-resultados" class="level2">
<h2 class="anchored" data-anchor-id="v.-resultados">V. Resultados</h2>
<p>El grupo estuvo conformado por 6 personas, en la cual se etiqueto 50 imagenes en total.</p>
<p>A continuacion presento evidencia de sus partes realizadas:</p>
<ul>
<li>Jheyner Villegas Mas:</li>
</ul>
<p><img src="images/clipboard-4176060573.png" class="img-fluid"></p>
<p><img src="images/clipboard-1736271852.png" class="img-fluid"></p>
<ul>
<li>Magaly Saldaña Bazán:</li>
</ul>
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2016.34.06_db2e359f.jpg" class="img-fluid"></p>
<ul>
<li>Desly Nicoll Carranza Gonzales:</li>
</ul>
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2015.14.29_0d468ef9.jpg" class="img-fluid"></p>
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2015.14.41_772e5eb6.jpg" class="img-fluid"></p>
<ul>
<li>Mady Isabel Vela LLaja:</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2014.59.38_0c999798.jpg" class="img-fluid figure-img"></p>
<figcaption><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2014.59.38_9a01f6a3.jpg" class="img-fluid figure-img"></figcaption>
</figure>
</div>
<ul>
<li>Noelia patricia Bustamante Lopez:</li>
</ul>
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2015.07.08_5343417a.jpg" class="img-fluid"></p>
<p><img src="images/Imagen%20de%20WhatsApp%202024-12-12%20a%20las%2015.06.50_c3487e46.jpg" class="img-fluid"></p>
<ul>
<li>Liany Damaris Monsalve Soto:</li>
</ul>
<p><img src="images/clipboard-522333895.png" class="img-fluid"></p>
</section>
<section id="vi.-conclusión" class="level2">
<h2 class="anchored" data-anchor-id="vi.-conclusión">VI. Conclusión</h2>
<p>El proceso de etiquetado de imágenes utilizando herramientas como Label Studio, en combinación con plataformas de gestión de entornos como Anaconda, demuestra la importancia de contar con un flujo de trabajo organizado y eficiente. La creación de un dataset de 50 imágenes etiquetadas con hojas y monedas no solo permitió explorar las capacidades de estas herramientas, sino que también sentó las bases para futuros proyectos en análisis de imágenes y aprendizaje automático.</p>
<p>El uso de Anaconda garantizó un entorno estable para la instalación y ejecución de Label Studio, simplificando el manejo de dependencias y asegurando la reproducibilidad del proyecto. Por su parte, Label Studio facilitó el etiquetado preciso de las imágenes gracias a su interfaz intuitiva y funcionalidades avanzadas.</p>
<p>Este proyecto pone en evidencia el valor de las herramientas tecnológicas en la generación de datasets de calidad, lo que resulta esencial en aplicaciones académicas, industriales y científicas.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>